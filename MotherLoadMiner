{$UNDEF SCRIPT_ID}{$DEFINE SCRIPT_ID := '7bc987a4-3f39-4dd1-840a-6c298132db22'}
{$UNDEF SCRIPT_REVISION}{$DEFINE SCRIPT_REVISION := '1'}
program AeroMLM;
{$DEFINE SRL_USE_REMOTEINPUT}
{$I SRL-T/OSR.simba}
{$I WaspLib/osr.simba}

Const
{---------Start setup---------}
{ General settings }
  SAMEZONE     = False;      // Return to your previous mining zone
  LARGESACK    = True;       // Using an upgraded pay-dirt sack?
  DROPHAMMER   = True;       // Drop hammer after repairing the strut?
  SCREENWALK   = True;       // Walk via the mainscreen?
  HOPONCHAT    = True;       // Hop worlds if nearby player chat is detected
  PDIST        = 7;          // Distance from each player to ignore vein-targeting
  PERCSHIFT    = 16;         // Percent pixelshift to be considered 'mining'
  DEBUGMODE    = True;       // Enable debug mode?
  LOWERLEVELONLY = True;

{ Time settings }
  MAXRUNTIME   = 600;        // How long (in minutes) to run
  TAKEBREAKS   = True;       // Take (long) breaks?
  BREAKAFTER   = '135';      // Break after how many minutes?
  BREAKFOR     = '15';       // Break for how many minutes?
  DOSLEEP      = False;       // Take extended sleep breaks?
  SLEEPAT      = '11:30:00'; // Begin sleep at this time
  SLEEPFOR     = '1';        // Sleep for how many hours?
{ Player Settings }
  PNAME        = '';
  PPASS        = '';
  WORLDLIST    = [305..307,313..315,320..323,329..332,337..340,443..446,477..482,
                  484..493];
{----------End setup----------}

Type
  EState = (
    MINING,HANDLE_LADDER,DEPOSIT_PAYDIRT,DEPOSIT_ORES
  );

  TZone = record
    Block     : TPoint;
    Area,Veins,
    WalkTiles : TPointArray;
  end;

  TMSObject = record
    Color   : TCTS2Color;
    Tiles   : TPointArray;
    UpText,
    Options : TStringArray;
    WalkTile: TPoint;
    Expand  : Int32;
  end;

  TScript = record
    Version             : String;
    State               : EState;
    StartXP,CoalC,
    GoldC,MithC,
    AddyC,RuneC,
    NugC,ToolSlot,
    PayDirtLimit,
    DTM_PayDirt,
    FailCount,MsgCount  : Int32;
    ShutdownTime        : Int64;
    PrevZone            : TZone;
    LadderObj,HopperObj,
    StrutObj,SackObj,
    DBObj,WalkObj       : TMSObject;
    EmptyGemBag,
    WalkSearch,DidClick : Boolean;
    UpperLevelBounds    : TPointArray;
    Worlds              : TIntegerArray;
    Zones               : Array of TZone;
    TrueRunTime,
    BlockCoolDown       : TStopwatch;
    RSW                 : TRSWalker;
  end;

  TRSDepositBoxItem = record
    Item: TRSItem;
    Quantity: Int32;
  end;

Var
  Bot : TScript;

Const
  DBTile      : TPoint = [322,220];
  LadderBTile : TPoint = [305,182];
  LadderTTile : TPoint = [305,178];
  HammerTile  : TPoint = [293,181];
  HopperTile  : TPoint = [276,188];
  SackTile    : TPoint = [275,240];
  StrutNTile  : TPoint = [253,200];
  StrutSTile  : TPoint = [253,223];

procedure TScript.WriteMsg(Message: String);
begin
  WriteLn('[Bot]: '+Message);
end;

function String.Replicate(Count: Integer): String;
var i: SizeInt;
begin
 Result:='';
 for i := 1 to Count do
   Result := Result + Self;
end;

// by Rasta Magician, veteran SRL-er
function ProgReport(
                           ResultType:int32; ScriptName, ScriptAuthor, ScriptVersion: String;
                           VarNames: TStringArray;
                           VarValues: TVariantArray
                          ): Variant;
var
  TSA        : TStringArray;
  s,s2       : String;
  s3         : String := '=';
  s4         : String := ' ';
  i, i2, L   : Int32;
begin
  if (ResultType = 2) then
    Result := '';

  if length(VarNames) <> Length(VarValues) then
  begin
    Writeln('VarNames and VarValues must be the same length');
    exit;
  end;
  SetLength(TSA, 3 + Length(VarNames) + 4);
  s2 := 'by '+ScriptAuthor;

  TSA[0] := s3;
  TSA[1] := ScriptName.Capitalize+' '+ScriptVersion;
  TSA[2] := s2;
  TSA[3] := s3;

  i2 := 3 + Length(VarNames);

  for i:= 4 to i2 do
    L := Max(L, Length(VarNames[i-4]));

  for i:= 4 to i2 do
  begin
    s := VarValues[i-4];
    TSA[i] := Padr((VarNames[i-4]).Capitalize, L)+' : '+ s.Capitalize;
  end;

  TSA[i2+1] := s3;
  TSA[i2+2] := ScriptName.Capitalize+' '+ScriptVersion;
  TSA[i2+3] := s3;

  i2 := 0;
  for i:= 0 to High(TSA) do
    i2 := Max(i2, Length(TSA[i]));

  TSA[0]           := s3.Replicate(i2);
  TSA[3]           := s3.Replicate(i2);
  TSA[High(TSA)-2] := s3.Replicate(i2);
  TSA[High(TSA)]   := s3.Replicate(i2);

  TSA[2] := s4.Replicate(round((i2 - Length(TSA[2]))/2)) + TSA[2]; //centering by ScriptAuthor
  TSA[High(TSA)-1] := s4.Replicate(round((i2 - Length(TSA[High(TSA)-1]))/2)) + TSA[High(TSA)-1];

  for i:= 0 to High(TSA) do
    if (TSA[i][1] = s3) then
      case ResultType of
        0 : writeln     ('[='+Padr(TSA[i], i2)+'=]');
        1 : writeln     ('[='+Padr(TSA[i], i2)+'=]');
        2 : Result := Result + '[='+Padr(TSA[i], i2)+'=]' + chr(13);
        else begin Writeln('Invalid Result Type'); exit; end;
      end
    else
      case ResultType of
        0 : writeln     ('[ '+Padr(TSA[i], i2)+' ]');
        1 : writeln     ('[ '+Padr(TSA[i], i2)+' ]');
        2 : Result := Result + '[ '+Padr(TSA[i], i2)+' ]' + chr(13);
        else begin Writeln('Invalid Result Type'); exit; end;
      end;

  if not ResultType = 2 then Result := true;
end;

procedure TScript.Report();
var
  XpGained: Int32;
  RunTime: Int64;
  SArr: TStringArray;
  VArr: TVariantArray;
begin
  XpGained := XPBar.Read()-Self.StartXP;
  RunTime  := Self.TrueRunTime.ElapsedTime();
  if (not DEBUGMODE) then
    ClearDebug();

  SArr := ['Runtime','XP gained','Nuggets','Coal','Gold','Mithril','Adamantite','Runite'];
  VArr := [SRL.MsToTime(GetTimeRunning, Time_Short),
            ToStr(Round(XpGained, 2), '(', Round(XpGained / (RunTime / 1000 / 60 / 60)), ' / hr)'),
            ToStr(Self.NugC, '(', Round(Self.NugC / (RunTime / 1000 / 60 / 60)), ' / hr)'),
            ToStr(Self.CoalC, '(', Round(Self.CoalC / (RunTime / 1000 / 60 / 60)), ' / hr)'),
            ToStr(Self.GoldC, '(', Round(Self.GoldC / (RunTime / 1000 / 60 / 60)), ' / hr)'),
            ToStr(Self.MithC, '(', Round(Self.MithC / (RunTime / 1000 / 60 / 60)), ' / hr)'),
            ToStr(Self.AddyC, '(', Round(Self.AddyC / (RunTime / 1000 / 60 / 60)), ' / hr)'),
            ToStr(Self.RuneC, '(', Round(Self.RuneC / (RunTime / 1000 / 60 / 60)), ' / hr)')];

  if TAKEBREAKS then
  begin
    SArr += 'Until break';
    VArr += Antiban.TimeUntilBreak(Antiban.Breaks[1]);
  end;

  if DOSLEEP then
  begin
    SArr += 'Until sleep';
    VArr += SRL.MsToTime(Max(0, Round(Antiban.Sleeps[0].NextAtTime - GetTimeRunning)), TIME_BARE);
  end;

  SArr += 'Shutdown';
  VArr += ToStr(SRL.MsToTime(Self.ShutdownTime - GetTimeRunning, Time_Short));

  ProgReport(1, 'AeroMLM','Flight', Self.Version, SArr, VArr);
end;

// Combination of miss mouse + slowing near the target destination
procedure TMouse.HumanMove(Point: TPoint);
var
  mPt: TPoint;
  S: Int32;
  Miss: Double;
  Range: Int64;
begin
  S := Self.Speed;
  Range := Trunc(Power(Self.Position().DistanceTo(Point), 0.80)); // how much possible range to miss
  Miss := SRL.SkewedRand(0.7, 0.1, 1.8); // Where miss will happen. 1 = destination (P).

  mPt.X := Trunc((1-Miss)*Self.Position().X + Miss*Point.X);
  mPt.Y := Trunc((1-Miss)*Self.Position().Y + Miss*Point.Y);

  mPt.X += SRL.NormalRange(-Range, Range);
  mPt.Y += SRL.NormalRange(-Range, Range);

  Self.Move(mPt);
  Self.Speed := round(S*0.70);
  Self.Move(Point);
  Self.Speed := S;
end;

function TRSMainScreen.DidRedClick: Boolean; override;
var
  Area: TBox:=Box(Mouse.Position(), 10, 10);
  i: Int32;
  T: TCountdown;
  TPA: TPointArray;
  Cols: Array of TCTS1Color:=[CTS1(255,0),CTS1(262600,0)];
begin
  Area.LimitTo(Self.Bounds);

  T.Init(250);
  While T.TimeRemaining>0 do
  begin
    for i:=0 to High(Cols) do
      if SRL.FindColors(TPA, Cols[i], Area)>0 then
        Exit(True);

    WaitEx(50,5);
  end;
end;

// Undo the bogged down version in WaspLib
function TRSChooseOption.Select(Text: TStringArray; MouseAction: Int32 = MOUSE_LEFT; CaseSensitive: Boolean = True; CloseIfNotFound: Boolean = True): Boolean; override;
var
  Choices: TRSChooseOption_OptionArray;
  I, J: Int32;
begin
  if Self.Open() then
  begin
    Wait(0, 750, wdLeft);

    Choices := GetOptions();

    for I := 0 to High(Choices) do
      for J := 0 to High(Text) do
        if (CaseSensitive and (Text[J] in Choices[I].Text)) or ((not CaseSensitive) and (Lowercase(Text[J]) in Lowercase(Choices[I].Text))) then
        begin
          Self.Select(Choices[I], MouseAction);
          Exit(True);
        end;

    if CloseIfNotFound then
    begin
      WaitEx(400, 150);

      Self.Close();
    end;
  end;
end;

function TRSWalker.MSInMMPoly(MSPt: TPoint; Area: TPointArray; MyPos: TPoint=[0,0]): Boolean;
var
  i: Int32;
  MMPnt: TPoint;
  Rads: Double;
  MMPoly: TPointArray;
begin
  Rads := Minimap.GetCompassAngle(False);
  if (MyPos = [0,0]) then
    MyPos := Self.GetMyPos();

  for i:=0 to high(Area) do
  begin
    MMPnt := Self.WorldToMM(MyPos, Area[i], Rads);
    if Minimap.IsPointOn(MMPnt) then
      MMPoly += MMPnt;
  end;

  Result := SRL.PointInPoly(Mainscreen.PointToMM(MSPt).ToPoint(), MMPoly);
end;

function TRSDepositBox.CountSlots(): Int32;
var
  Box: TBox;
  Pt: TPoint;
  TPA: TPointArray;
begin
  if not Self.IsOpen() then
    Exit;

  if SRL.FindColors(TPA, RS_ITEM_BORDER, Self.Bounds) > 0 then
    for Box in Self.GetSlotBoxes() do
      for Pt in TPA do
        if Pt.InBox(Box) then
        begin
          Inc(Result);
          break;
        end;
end;

function TRSDepositBox.CountItem(Item: TRSItem): Int32;
begin
  if not Self.IsOpen() then
    Exit;

  Result := Length(ItemFinder.Find(Item, Self.GetSlotBoxes()));
end;

function TRSDepositBox.CountItemStack(Item: TRSItem): Int32;
var
  B: TBox;
begin
  Result := -1;
  if Self.FindItem(Item, B) then
    Result := SRL.GetItemAmount(B);
end;

function TRSDepositBox.ClickItem(Item: TRSItem; Option: String = ''): Boolean;
var
  B: TBox;
begin
  if Self.FindItem(Item, B) then
  begin
    Mouse.Move(B);
    if Option <> '' then
      Result := ChooseOption.Select(Option)
    else
    begin
      Mouse.Click(MOUSE_LEFT);

      Result := True;
    end;
  end;
end;

function TScript.FindHopperMsg(): Boolean;
begin
  if (not RSClient.IsLoggedIn) then Exit;
  Result := ('finish' in Chat.GetMessage(CHAT_INPUT_LINE - 1, [CHAT_COLOR_BLACK])) or
            ('finish' in Chat.GetMessage(CHAT_INPUT_LINE - 2, [CHAT_COLOR_BLACK]));
end;

function TRSLogout.GetCurrentWorld: Int32;
begin
  if (not Self.IsWorldSwitcherOpen()) then
  begin
    Self.Open();
    if Self.GetButton(ERSLogoutButton.WORLD_SWITCHER).Click then
      WaitUntil(Self.IsWorldSwitcherOpen(), 500, 6000);
  end;

  Result := OCR.RecognizeNumber([Self.Bounds.X1+17,Self.Bounds.Y1,Self.Bounds.X1+150,Self.Bounds.Y1+20], TOCRColorRule.Create([2070783]), RS_FONT_BOLD_12);
end;

function TRSLogout.SwitchWorlds(World:Int32): Boolean;
var
  B: TBox;
  mmCP: TPoint;
  T: TCountdown;
  Found,Down: Boolean;
  ListBox: TBox := [Self.Bounds.X1+17,Self.Bounds.Y1+36,Self.Bounds.X1+42,Self.Bounds.Y2-38];
  VisibleWorld: Int32;
  MMTiles: TPointArray;
begin
  if (Self.GetCurrentWorld = World) then Exit(True);

  // Read the first visible members world from the world list
  VisibleWorld := OCR.RecognizeNumber(ListBox, TOCRColorRule.Create([61680,14737632]), RS_FONT_PLAIN_12);
  Mouse.Move(Self.Bounds.Expand(-5,-36), True);

  if Self.GetScrollPosition <= 25 then
    Down := True
  else
    Down := False;

  T.Init(15000);
  While InRange(Self.GetScrollPosition, 1, 99) do
  begin
    if OCR.LocateText(ListBox, ToStr(World), RS_FONT_PLAIN_12,  TOCRColorRule.Create([61680,14737632]), B) = 1 then
    begin
      Found := True;
      Break;
    end;

    if Down then
      Mouse.Scroll(SRL.NormalRange(1,3), True)
    else
      Mouse.Scroll(SRL.NormalRange(1,3), False);

    WaitEx(75, 15);
    if T.TimeRemaining < 1 then
      break;
  end;

  if (not Found) then
    if (not Down) then
    begin
      Mouse.Scroll(SRL.NormalRange(1,3), False);
      T.Init(15000);
      While Self.GetScrollPosition >= 1 do
      begin
        if OCR.LocateText(ListBox, ToStr(World), RS_FONT_PLAIN_12,  TOCRColorRule.Create([61680,14737632]), B) = 1 then
        begin
          Found := True;
          Break;
        end;

        Mouse.Scroll(SRL.NormalRange(1,3), False);
        WaitEx(75, 15);
        if T.TimeRemaining < 1 then
        begin
          Writeln('[SwitchWorlds]: Timeout [0]');
          Exit;
        end;
      end;
    end else
    begin
      Mouse.Scroll(SRL.NormalRange(1,3), True);
      T.Init(15000);
      While Self.GetScrollPosition <= 99 do
      begin
        if OCR.LocateText(ListBox, ToStr(World), RS_FONT_PLAIN_12,  TOCRColorRule.Create([61680,14737632]), B) = 1 then
        begin
          Found := True;
          Break;
        end;

        Mouse.Scroll(SRL.NormalRange(1,3), True);
        WaitEx(75, 15);
        if T.TimeRemaining < 1 then
        begin
          Writeln('[SwitchWorlds]: Timeout [1]');
          Exit;
        end;
      end;
    end;

  if Found then
  begin
    for 1 to 2 do
    begin
      Mouse.Click(B, MOUSE_LEFT);
      if WaitUntil(Bot.FindHopperMsg, 75, 3000) then
      begin
        mmCP    := Minimap.Center;
        MMTiles := [[mmCP.X-4,mmCP.Y],[mmCP.X,mmCP.Y-4],[mmCP.X+4,mmCP.Y],[mmCP.X,mmCP.Y+4]];
        Mouse.Move(Minimap.StaticToMsRect(MMTiles[Random(0,3)],0));
        if (not Mainscreen.IsUpText('Walk here', 75)) then
          ChooseOption.Select('Walk here')
        else
          Mouse.Click(MOUSE_LEFT);

        WaitUntil(Minimap.IsPlayerMoving, 115, 2200);
        While Minimap.IsPlayerMoving do
          Wait(115);
      end else
        break;
    end;

    Result := WaitUntil((Self.GetCurrentWorld = World), 115, 15000);
  end;
end;

function TScript.HopWorlds(): Boolean;
var World: Int32;
begin
  repeat
    World := WORLDLIST[Random(0, Length(WORLDLIST)-1)];
    if InIntArray(Self.Worlds, World) then Continue;
    Self.Worlds += World;
    if Self.Worlds.Len >= Length(WORLDLIST) then // Hopped into every world on our list, so reset local worldlist
      Self.Worlds := [];
  until(World > 0);

  Self.WriteMsg('Hopping to world '+ToStr(World));
  Chat.ClickContinue();
  DepositBox.Close();
  Result := Logout.SwitchWorlds(World);
end;

procedure TScript.CheckForChat();
var
  Msg6,Msg7: String;
  Hopped: Boolean;
begin
  Msg6 := Chat.GetMessage(6, [CHAT_COLOR_BLACK,CHAT_COLOR_BLUE]);
  Msg7 := Chat.GetMessage(7, [CHAT_COLOR_BLACK,CHAT_COLOR_BLUE]);

  if (Pos(':', Msg7) < 1) then
    if (Pos(':', Msg6) < 1) then Exit;

  if (Pos('RuneScape:', Msg6) < 1) or (Pos('RuneScape:', Msg7) < 1) then
  begin
    if OCR.Recognize(Mainscreen.Bounds.Expand(-75), TOCRColorRule.Create([65535]), RS_FONT_BOLD_12) <> '' then
    begin
      Self.WriteMsg('Player chat detected nearby, hopping worlds...');
      for 1 to 3 do
        if Self.HopWorlds then
        begin
          Hopped := True;
          break;
        end;

      if (not Hopped) then
      begin
        Logout.ClickLogout();
        TerminateScript('Failed to hop worlds');
      end;
    end;
  end;
end;

procedure TAntiban.DoLoseFocus();
begin
  Self.LoseFocus(SRL.NormalRange(3700,5000));
end;

procedure BreakPause(Task: PBreakTask);
Var T: PBreakTask;
begin
  Bot.TrueRunTime.Pause;
  T := Task;
end;

procedure BreakResume(Task: PBreakTask);
Var T: PBreakTask;
begin
  if GetTimeRunning() > Bot.ShutdownTime then
    TerminateScript('Time to shutdown');

  Bot.TrueRunTime.Resume;
  T := Task;
end;

procedure SleepPause(Task: PSleepTask);
Var T: PSleepTask;
begin
  Bot.TrueRunTime.Pause;
  T := Task;
end;

procedure SleepResume(Task: PSleepTask);
Var T: PSleepTask;
begin
  if GetTimeRunning() > Bot.ShutdownTime then
    TerminateScript('Time to shutdown');

  Bot.TrueRunTime.Resume;
  T := Task;
end;

function TSRL.PercentShift(Area: TBox; WaitTime: Int32): Int32;
var
  tLen,sLen: Int32;
begin
  tLen := length(TPAFromBox(Area));
  sLen := SRL.GetPixelShift(Area, WaitTime);
  Result := Round((sLen/tLen)*100);
end;

function TIntegerArray.GetRarest(): Int32;
var
  i,hits,least: Int32;
begin
  Self.Sort();
  for i:=0 to high(Self) do
  begin
    hits := Length(Self.FindAll(Self[i]));
    if i<1 then
      least := Self[i]
    else if i>0 then
      if hits < Length(Self.FindAll(Self[i-1])) then
        least := Self[i];
  end;

  Result := least;
end;

procedure TAntiBan.HoverMSTile(DotType: ERSMinimapDot; RightClick: Boolean = False);
var
  Tries: Int32;
  a: Double;
  rDot: TPoint;
  MSBox: TBox;
  Dots,cTPA: TPointArray;
  cArr: TIntegerArray;
begin
  Dots := Minimap.GetDots(DotType);
  if Dots.Len() < 1 then Exit;
  a := Minimap.GetCompassAngle(False);
  repeat
    Inc(Tries);
    rDot := Dots[Random(Low(Dots),High(Dots))];
    MSBox := Minimap.VecToMsRect(Vec3(rDot.X + 2, rDot.Y + 2, 0), 1, 1, a).Bounds();
    if MainScreen.Bounds.Contains(MSBox) then
    begin
      Self.DebugLn('Hovering random ' + toStr(DotType));
      cArr := GetColors(TPAFromBox(MSBox));
      SRL.FindColors(cTPA, CTS1(cArr.GetRarest(), 30), MSBox);
      Mouse.HumanMove(cTPA.Mean());
      if RightClick then
        Mouse.Click(MOUSE_RIGHT);

      wait(1500, 2700);
      if RightClick then
        ChooseOption.Close();
      Exit;
    end;
  until(Tries > 10);
end;

procedure TAntiban.HoverMSNPCs();
begin
  Self.HoverMSTile(ERSMinimapDot.NPC);
end;

procedure TAntiban.HoverMSPlayers();
begin
  Self.HoverMSTile(ERSMinimapDot.PLAYER);
end;

procedure TAntiban.HoverMSItems();
begin
  Self.HoverMSTile(ERSMinimapDot.ITEM);
end;

procedure TScript.DoLoseFocus();
Var T: Int32;
begin
  T := SRL.NormalRange(1700,5000);
  Antiban.DebugLn('Losing focus for '+SRL.MsToTime(T, Time_Short));
  Antiban.LoseFocus(T);
end;

procedure TScript.SetupAntiban();
var SleepTime: String;
begin
  Antiban.Skills += ERSSKILL.MINING;
  Antiban.AddTask(ONE_MINUTE*4,  @Antiban.SmallRandomMouse);
  Antiban.AddTask(ONE_MINUTE*7,  @Self.DoLoseFocus);
  Antiban.AddTask(ONE_MINUTE*8,  @Antiban.HoverMSItems);
  Antiban.AddTask(ONE_MINUTE*8,  @Antiban.HoverMSNPCs);
  Antiban.AddTask(ONE_MINUTE*6,  @Antiban.HoverMSPlayers);
  Antiban.AddTask(ONE_MINUTE*25, @Antiban.HoverSkills);
  Antiban.AddBreak(ONE_MINUTE*18, ONE_SECOND*40, 0.2, 0.0);

  if TAKEBREAKS then
  begin
    Antiban.AddBreak(ONE_MINUTE*StrToInt(BREAKAFTER),ONE_MINUTE*StrToInt(BREAKFOR), 0.1, 1.0);
    Antiban.OnStartBreak  := @BreakPause;
    Antiban.OnFinishBreak := @BreakResume;
  end;

  if DOSLEEP then
  begin
    SleepTime := SLEEPAT;
    Antiban.AddSleep(SleepTime, StrToInt(SLEEPFOR) * ONE_HOUR, 0.1, 1.0);
    Antiban.OnStartSleep  := @SleepPause;
    Antiban.OnFinishSleep := @SleepResume;
  end;
end;

function TScript.GetSackCount(): Int32;
var
  BorderCol: TCTS1Color := CTS1(2306104,0);
  NumCols: TIntegerArray := [13158600,255];
  BorderTPA: TPointArray;
begin
  if (not RSClient.IsLoggedIn) then Exit;
  with Mainscreen do
    SRL.FindColors(BorderTPA, BorderCol, [X1, Y1, X1+100, Y1+100]);
  if BorderTPA.Len < 1 then Exit;

  Result := OCR.RecognizeNumber(BorderTPA.Bounds, TOCRColorRule.Create(NumCols), RS_FONT_QUILL);
end;

function TScript.FindReachMsg(): Boolean;
var
  i,Count: Int32;
begin
  if (not RSClient.IsLoggedIn) then Exit;
  for i:=0 to CHAT_INPUT_LINE - 1 do
    if 't reach that' in Chat.GetMessage(i, [CHAT_COLOR_BLACK]) then
      Inc(Count);

  Result := Count >= 3;
end;

function TScript.HasOres(): Boolean;
var
  Ore: TRSItem;
  Ores: TStringArray := ['Coal','Gold ore','Mithril ore','Adamantite ore','Runite ore'];
begin
  for Ore in Ores do
    if Inventory.ContainsItem(Ore) then
      Exit(True);
end;

function TScript.HasTool(): Boolean;
var
  i,Slot: Int32;
  Picks: TStringArray := ['Bronze','Iron','Steel','Mithril','Adamant','Rune',
                          'Dragon','Infernal','Crystal'];
begin
  if (not RSClient.IsLoggedIn) then Exit;

  for i:=0 to High(Picks) do
    if Inventory.FindItem(Picks[i]+' pickaxe', Slot) then
    begin
      Self.ToolSlot := Slot;
      Exit(True);
    end;
  for i:=0 to High(Picks) do
    if Equipment.FindItem(Picks[i]+' pickaxe') then
      Exit(True);
end;

function TScript.GetPaydirtSlots: TIntegerArray;
var
  i: Int32;
  Pt: TPoint;
  Slots: TBoxArray;
  Pts: TPointArray;
begin
  if (not RSClient.IsLoggedIn) then Exit;
  Inventory.Open;
  if (not FindDTMs(Self.DTM_PayDirt, Pts, Inventory.Bounds)) then Exit;

  Slots := Inventory.GetSlotBoxes();
  for i:=0 to 27 do
    for Pt in Pts do
      if Slots[i].Contains(Pt) then
      begin
        SetLength(Result, Length(Result)+1);
        Result[High(Result)] := i;
      end;

  Result.ClearDuplicates;
end;

function TScript.CountPayDirt(): Int32;
begin
  if (not RSClient.IsLoggedIn) then Exit;
  Result := Length(Self.GetPaydirtSlots);
end;

function TScript.GetCurrentZone(MyPos: TPoint=[0,0]): TZone;
var
  Zone: TZone;
begin
  if (not RSClient.IsLoggedIn) then Exit;
  if MyPos.X <= 1 then
    MyPos := Self.RSW.GetMyPos();

  for Zone in Self.Zones do
    if SRL.PointInPoly(MyPos, Zone.Area) then
      Exit(Zone);

  Result := [];
end;

function TScript.OnUpperLevel(): Boolean;
var MyPos: TPoint:=Self.RSW.GetMyPos;
begin
  if (not RSClient.IsLoggedIn) then Exit;
  if Self.GetCurrentZone(MyPos) <> [] then Exit(True);
  Result := SRL.PointInPoly(MyPos, Self.UpperLevelBounds);
end;

function TScript.WaterIsFlowing(): Boolean;
var
  WaterCol: TCTS2Color := CTS2(13023407,9,0.07,0.43);
begin
  if (not RSClient.IsLoggedIn) then Exit;
  Result := SRL.CountColor(WaterCol, Mainscreen.Bounds) > 1000;
end;

function TScript.GetRandomZone(ExcludeMyZone:Boolean=False): TZone;
var
  Rand: Int32;
  Zones: Array of TZone := Self.Zones;
begin
  if (not RSClient.IsLoggedIn) then Exit;

  repeat
    Rand := RandomRange(0, Length(Zones));
    if ExcludeMyZone then
      if Zones[Rand] = Self.GetCurrentZone() then Continue;
    Result := Zones[Rand];
  until(Result <> []);
end;

function TScript.GetZoneAngle(Best: Boolean=True; MyZone: TZone; MyPos: TPoint): Int32;
begin
  if Best then
    case MyZone of
      Self.Zones[0]: Exit(SRL.NormalRange(33,55));
      Self.Zones[1]:
      begin
        if MyPos.Y > 163 then
          Exit(SRL.NormalRange(165,195));

        if MyPos.X >= 334 then
          Exit(SRL.NormalRange(255,285))
        else
        begin
          if InRange(Minimap.GetCompassAngle(), 180, 360) then
            Exit(SRL.NormalRange(350,360));
          if InRange(Minimap.GetCompassAngle(), 0, 179) then
            Exit(SRL.NormalRange(0,10));
        end;
      end;
      Self.Zones[2]:
      begin
        if MyPos.X <= 316 then
          Exit(SRL.NormalRange(255,285))
        else
          Exit(SRL.NormalRange(165,195));
      end;
    end;
  if (not Best) then
    case MyZone of
      Self.Zones[0]: Exit(SRL.NormalRange(33,55));
      Self.Zones[1]:
      begin
        if MyPos.Y < 164 then
          Exit(SRL.NormalRange(165,195))
        else
        begin
          if SRL.Dice(50) then
            Exit(SRL.NormalRange(350,360))
          else
            Exit(SRL.NormalRange(0,10));
        end;
      end;
      Self.Zones[2]:
      begin
        if MyPos.X <= 316 then
          Exit(SRL.NormalRange(75,105))
        else
          Exit(SRL.NormalRange(255,285));
      end;
    end;
end;

function TScript.GetVeinsInMyZone(MyZone: TZone; AvoidPlayers: Boolean=True): TPointArray;
var
  i: Int32;
  B,PBox: TBox;
  Dot,MMPnt,VeinPt: TPoint;
  MyPos: TPoint := Self.RSW.GetMyPos;
  Skip: Boolean;
  VeinRect: TRectangle;
  VeinTPA,Dots: TPointArray;
  VeinCol: TCTS2Color := CTS2(9540251,21,0.10,0.13);
begin
  if (not RSClient.IsLoggedIn) then Exit;
  Dots := Minimap.GetDots(ERSMinimapDot.PLAYER);
  PBox := Mainscreen.GetPlayerBox();

  for i:=0 to High(MyZone.Veins) do
  begin
    VeinRect := Self.RSW.GetTileMSEx(MyPos,MyZone.Veins[i],5);
    VeinRect := VeinRect.Expand(7);
    B := VeinRect.Bounds;
    B.LimitTo(Mainscreen.Bounds);

    if SRL.FindColors(VeinTPA, VeinCol, B) then
      if (not PBox.Contains(VeinTPA.Mean())) then
      begin
        VeinPt := VeinTPA.Mean;
        if MyZone.Block.X > 0 then // Zone [1],[2]
          VeinPt.Y += Mainscreen.NormalizeDistance(25);
        VeinPt.Random(4,4,True);
        if AvoidPlayers then
        begin
          MMPnt := MainScreen.PointToMM(VeinPt).ToPoint();
          for Dot in Dots do
            if MMPnt.DistanceTo(Dot) <= PDIST then
            begin
              Skip := True;
              break;
            end;

          if (not Skip) then
            Result += VeinPt;

          Skip := False;
        end else
          Result += VeinPt;
      end;
  end;

  Result.Sort([PBox.Middle.X,PBox.Y1]);
end;

function TScript.GetRandomFreeZone(): TZone;
var
  Dot: TPoint;
  MyPos: TPoint:=Self.RSW.GetMyPos;
  Skip: Boolean;
  Zone: TZone;
  Dots: TPointArray;
  FreeZones: Array of TZone;
begin
  if (not RSClient.IsLoggedIn) then Exit;
  Dots := Minimap.GetDots(ERSMinimapDot.PLAYER);

  for Zone in Self.Zones do
  begin
    Skip := False;

    for Dot in Dots do
      if Self.RSW.MSInMMPoly(Minimap.PointToMs(Dot), Zone.Area, MyPos) then
      begin
        Skip := True;
        break;
      end;

    if Skip then
      Continue
    else
      FreeZones += Zone;
  end;

  if Length(FreeZones) > 0 then
    Result := FreeZones[RandomRange(0, Length(FreeZones))]
  else
    Result := Self.GetRandomZone(True);
end;


function TScript.TakeGroundItems(): Boolean;
var
  a: Double;
  MSBox: TBox;
  Dots,TPA: TPointArray;
  ATPA: T2DPointArray;
  Finder: TRSObjectFinder;
  MSRect: TRectangle := Minimap.PointToMsRect(Minimap.Center, 1, 1);
begin
  if (not RSClient.IsLoggedIn) then Exit;
  Dots := Minimap.GetDots(ERSMinimapDot.ITEM);
  if Dots.Len() > 0 then
  begin
    if DEBUGMODE then
      Self.WriteMsg('Picking up pay-dirt');

    Dots.Sort(Minimap.Center);
    a := Minimap.GetCompassAngle(False);

    MSBox := Minimap.VecToMsRect(Vec3(Dots[0].X + 2, Dots[0].Y + 2, 0), 1, 1, a).Bounds();
    MSBox.Expand(10);
    if MainScreen.Bounds.Contains(MSBox) then
    begin
      Finder.Colors += CTS2(7694198,10,5.20,0.43);
      Finder.ClusterDistance := 5;

      ATPA := MainScreen.FindObject(Finder, MSBox);
      if ATPA.Len < 1 then Exit();

      ATPA.SortByMiddle([Mainscreen.GetPlayerBox.Middle.X, Mainscreen.GetPlayerBox.Y2]);
      for TPA in ATPA do
      begin
        Mouse.HumanMove(TPA.Mean);
        if MainScreen.IsUpText('Take Pay', 115) then break;
      end;

      if (not MainScreen.IsUpText('Take Pay', 115)) then Exit;

      Mouse.Click(MOUSE_LEFT);
      Minimap.WaitFlag(0);
      Minimap.WaitPlayerMoving;
    end;
  end;

  Inventory.Open;

  for 1 to 4 do
  begin
    Mouse.HumanMove([MSRect.Mean.X+SRL.NormalRange(-7,7),MSRect.Mean.Y+SRL.NormalRange(-7,7)]);
    if MainScreen.IsUpText('Take Pay', 115) then
      break;
  end;

  if (not MainScreen.IsUpText('Take Pay')) then Exit;

  Repeat
    if (not RSClient.IsLoggedIn) then Exit;
    if MainScreen.IsUpText('Take Pay', 115) then
    begin
      Result := True;
      Mouse.Click(MOUSE_LEFT);
      WaitEx(750, 150);
    end else
      break;

    if 'take items' in Chat.GetMessage(CHAT_INPUT_LINE - 1, [CHAT_COLOR_BLACK]) then Exit;
    if Chat.GetChat <> '' then break;
  Until(Inventory.Count >= 28);
end;

function TMSObject.Find(out Pnt: TPoint): Boolean;
var
  B: TBox;
  i: Int32;
  Rect: TRectangle;
  ATPA: T2DPointArray;
  Finder: TRSObjectFinder;
  MyPos: TPoint := Bot.RSW.GetMyPos();
begin
  Finder.Colors += Self.Color;

  Finder.Erode := 2;
  Finder.ClusterDistance := 10;

  for i:=0 to Self.Tiles.Len-1 do
  begin
    Rect := Bot.RSW.GetTileMSEx(MyPos, Self.Tiles[i]);
    Rect := Rect.Expand(Self.Expand);
    B    := Rect.Bounds;

    B.LimitTo(MainScreen.Bounds);
    if (not MainScreen.IsVisible(B.Middle())) then Continue;

    ATPA := MainScreen.FindObject(Finder, B);
    if (ATPA.Len > 0) then
    begin
      Pnt := ATPA.Biggest().Mean();
      Exit(True);
    end else
      Continue;
  end;
end;

function TMSObject.Interact(): Boolean;
Var
  Pt: TPoint;
  Clicked: Boolean;
begin
  if (not Self.Find(Pt)) then
  begin
    if (not Bot.RSW.WalkBlind(Self.WalkTile, 30)) then
      Antiban.RandomRotate();

    while Minimap.IsPlayerMoving() do
    begin
      if (not Self.Find(Pt)) then Continue;
      ASyncMouse.Move(Pt);

      while ASyncMouse.IsMoving() do
      begin
        if Self.Find(Pt) then
          ASyncMouse.ChangeDestination(Pt);

        if MainScreen.IsUpText(Self.UpText) then
        begin
          Mouse.Click(MOUSE_LEFT);
          if (not MainScreen.DidRedClick) then Exit;
          Exit(True);
        end;
      end;
      if Clicked then Break;
    end;
  end else
    Mouse.Move(Pt);

  if (not Clicked) then
  begin
    if (not MainScreen.IsUpText(Self.UpText, 50)) then
    begin
      if Self.Find(Pt) then
        Mouse.Move(Pt);
      if (not MainScreen.IsUpText(Self.UpText, 50)) then
      begin
        if (not Bot.RSW.WalkBlind(Self.WalkTile, 30)) then
          Antiban.RandomRotate();
        Exit;
      end;
    end;

    Mouse.Click(MOUSE_LEFT);
    Result := MainScreen.DidRedClick;
  end;
end;

function TScript.InteractTile(Tile: TPoint; Col: TCTS2Color; UpText: TStringArray; Expand: Int32=3): Boolean;
var
  B: TBox;
  i: Int32;
  MSRect,CRect: TRectangle;
  Cluster: T2DPointArray;
  Finder: TRSObjectFinder;
begin
  MSRect := Self.RSW.GetTileMS(Tile, 0);
  MSRect := MSRect.Expand(Expand);
  B      := MSRect.Bounds;
  B.LimitTo(Mainscreen.Bounds);

  if (not MainScreen.IsVisible(B.Middle)) then Exit(False);

  Finder.Colors := [Col];
  Finder.ClusterDistance := 5;
  Cluster := MainScreen.FindObject(Finder, B);
  if (Cluster.Len > 0) then
  begin
    for i:=0 to high(Cluster) do
    begin
      CRect := Cluster[i].MinAreaRect();
      Mouse.Move(SRL.RandomPoint(CRect));
      if Mainscreen.IsUpText(UpText, 75) then
        Exit(True);
    end;
  end;
end;

function TScript.MineZoneBlock(Zone: TZone; Force: Boolean=False): Boolean;
var
  BlockCol: TCTS2Color := CTS2(1459023, 7, 0.07, 0.78);
  MyPos: TPoint := Self.RSW.GetMyPos;
  XP: Int32;
begin
  if (not RSClient.IsLoggedIn) then Exit;
  //if Self.BlockCoolDown.ElapsedTime() < 5000 then Exit;
  //writeln(mypos); terminatescript();
  if Force then Zone.Block := [314,167];
  //if (MyPos.X >= 315) or (MyPos.Y <= 167) then Zone.Block := [314,167];
  if Zone.Block.X > 0 then
  begin
    Self.BlockCoolDown.Reset();
    if DEBUGMODE then
      Self.WriteMsg('Clearing the rockfall');
    if MyPos.DistanceTo(Zone.Block) > 15 then
      Self.RSW.WalkBlind([Zone.Block.X+4,Zone.Block.Y-2], 0);

    if (not Self.InteractTile(Zone.Block, BlockCol, ['Rockfall'], 4)) then Exit(True); // Blockage already mined

    if Mainscreen.IsUpText('Rockfall', 75) then
    begin
      Mouse.Click(MOUSE_LEFT);
      if (not MainScreen.DidRedClick) then Exit;
      XP := XPBar.Read();
      if WaitUntil(Minimap.IsPlayerMoving(300), 75, 1500) then
        while Minimap.IsPlayerMoving(300) do
          Wait(115);

      WaitUntil((XPBar.Read() > XP), 75, 3100);
      Result := True;
    end;
  end;
end;

function TScript.TakeHammer(): Boolean;
var
  i: Int32;
  CrateCol: TCTS2Color := CTS2(2450557, 11, 0.06, 1.37);
begin
  if (not RSClient.IsLoggedIn) then Exit;

  if Inventory.ContainsItem('Hammer') then Exit(True);
  if DEBUGMODE then
    Self.WriteMsg('Taking a hammer');
  if Inventory.IsFull() then
  for i:=0 to 3 do
  begin
    Inventory.HoverSlot(i);
    if Mainscreen.IsUpText('Pay-dirt', 75) then
    begin
      Inventory.ClickSlot(i, 'Drop');
      wait(SRL.NormalRange(250,750));
      break;
    end;
  end;

  for 1 to 3 do
  begin
    if Self.InteractTile(HammerTile, CrateCol, ['Search','Crate']) then
    begin
      if Mainscreen.IsUpText(['Search','Crate'], 75) then
      begin
        Mouse.Click(MOUSE_LEFT);
        if (not MainScreen.DidRedClick) then Exit;
        Minimap.WaitFlag(3);

        Result := WaitUntil(Inventory.ContainsItem('Hammer'), 75, 6000);
      end;
    end;
    if Result then Exit(True);
  end;

  if (not Result) then
    Self.HopWorlds();
end;

function TScript.RepairStrut(): Boolean;
var
  StrutCol: TCTS2Color := CTS2(3627626, 10, 0.07, 0.17);
  XP: Int32;
  MyPos,Tile: TPoint;
begin
  if (not RSClient.IsLoggedIn) then Exit;

  if Self.WaterIsFlowing() then Exit(True);
  if (not Inventory.ContainsItem('Hammer')) then
    Self.TakeHammer();
  MyPos := Self.RSW.GetMyPos();
  if MyPos.DistanceTo(StrutNTile) < MyPos.DistanceTo(StrutSTile) then
    Tile := StrutNTile
  else
    Tile := StrutSTile;

  for 1 to 4 do
  begin
    if Self.InteractTile(Tile, StrutCol, ['Hammer','Broken']) then
    begin
      if Mainscreen.IsUpText(['Hammer','Broken'], 75) then
      begin
        Mouse.Click(MOUSE_LEFT);
        if (not MainScreen.DidRedClick) then Exit;
        Minimap.WaitFlag(5);

        XP := XPBar.Read();
        if (not WaitUntil(Self.WaterIsFlowing, 75, 15000)) then Exit(False);
        Result := True;
      end;
    end;
    if Result then
    begin
      if DROPHAMMER then
        if SRL.Dice(75) then
          Inventory.ShiftDrop(['Hammer'], DROP_PATTERN_REGULAR)
        else
          Inventory.ClickItem('Hammer', 'Drop');

      Exit(True);
    end;
  end;

  if (not Result) then
  begin
    if DEBUGMODE then
      Self.WriteMsg('Failed to repair the strut');
    Antiban.RandomRotate();
  end;
end;

procedure TScript.NavigateToZone(Zone: TZone);
var
  MyPos,RandTile: TPoint;
begin
  if (not RSClient.IsLoggedIn) then Exit;

  MyPos := Self.RSW.GetMyPos();
  if SRL.PointInPoly(MyPos, Zone.Area) then Exit;

  if DEBUGMODE then
    Self.WriteMsg('Navigating to vein zone');
   writeln zone;
  RandTile := Zone.WalkTiles[RandomRange(0, Length(Zone.WalkTiles))];
  for 1 to 3 do
    if Self.MineZoneBlock() then
      break;

  if (not Self.RSW.WalkBlind(RandTile)) then
    if Self.MineZoneBlock() then
      Self.RSW.WalkBlind(RandTile);

  Self.Report();
end;

procedure TScript.RelocateInZone();
var
  MyZone: TZone;
  MyPos,RandTile: TPoint;
begin
  if (not RSClient.IsLoggedIn) then Exit;

  MyPos := Self.RSW.GetMyPos();
  MyZone := Self.GetCurrentZone();
  if MyZone.WalkTiles.Len < 2 then Exit;
  RandTile := MyZone.WalkTiles[RandomRange(0, Length(MyZone.WalkTiles))];

  if DEBUGMODE then
    Self.WriteMsg('Navigating to different spot inside this zone');

  Self.RSW.WalkBlind(RandTile);
end;

procedure TScript.NavigateToPlace(Where: String);
var
  MyPos: TPoint;
  MyZone: TZone;
begin
  if (not RSClient.IsLoggedIn) then Exit;
  if DEBUGMODE then
    Self.WriteMsg('Navigating to '+Lowercase(Where));

  MyPos  := Self.RSW.GetMyPos();
  MyZone := Self.GetCurrentZone();

  case Where of
    'Ladder'     :
    begin
      if Self.OnUpperLevel() then
      begin
        if MyZone.Block.X > 0 then
          Self.MineZoneBlock(MyZone);
        MyPos := Self.RSW.GetMyPos();
        if MyPos.DistanceTo(LadderTTile) >= 10 then
        begin
          Self.WalkSearch := True;
          Self.WalkObj    := Self.LadderObj;
          if (not Self.RSW.WalkBlind([LadderTTile.X,LadderTTile.Y-4], 5)) then
            Antiban.RandomRotate();
        end;
      end else
      begin
        Self.WalkSearch := True;
        Self.WalkObj    := Self.LadderObj;
        if (not Self.RSW.WalkBlind([LadderBTile.X,LadderBTile.Y+4], 5)) then
          Antiban.RandomRotate();
      end;
    end;
    'Hopper'     :
    begin
      Self.WalkSearch := True;
      Self.WalkObj    := Self.HopperObj;
      if (not Self.RSW.WalkBlind([HopperTile.X+4,HopperTile.Y], 2)) then
        Antiban.RandomRotate();
    end;
    'Sack'       :
    begin
      Self.WalkSearch := True;
      Self.WalkObj    := Self.SackObj;
      if (not Self.RSW.WalkBlind([SackTile.X+8,SackTile.Y], 5)) then
        Antiban.RandomRotate();
    end;
    'DepositBox' :
    begin
      Self.WalkSearch := True;
      Self.WalkObj    := Self.DBObj;
      if (not Self.RSW.WalkBlind([DBTile.X-4,DBTile.Y], 5)) then
        Antiban.RandomRotate();
    end;
    'North strut': if (not Self.RSW.WalkBlind(StrutNTile, 5)) then Antiban.RandomRotate();
    'South strut': if (not Self.RSW.WalkBlind(StrutSTile, 5)) then Antiban.RandomRotate();
    'Block':
    begin

    end;
  end;
end;


function TScript.HandleLadder(): Boolean;
var
  Upper,Clicked: Boolean;
  LadRect: TRectangle;
  TPA: TPointArray;
  MyPos: TPoint := Self.RSW.GetMyPos;
  MyZone: TZone := Self.GetCurrentZone();
label
  Start;
begin
  if (not RSClient.IsLoggedIn) then Exit;

  if (MyPos.X >= 330) and (MyPos.Y >= 175) then
  begin
    if DEBUGMODE then
      Self.WriteMsg('Trapped, relocating');

    Self.MineZoneBlock([332,204]);
    Self.NavigateToZone(Self.Zones[0]);
  end;

  if DEBUGMODE then
    Self.WriteMsg('Climbing the ladder');

  Upper := WaitUntil(Self.OnUpperLevel, 75, 500);
  if Upper then
  begin
    if MyZone.Block.X > 0 then
      Self.MineZoneBlock();

    Self.LadderObj.WalkTile := [LadderTTile.X,LadderTTile.Y-4];
  end else
    Self.LadderObj.WalkTile := [LadderBTile.X,LadderBTile.Y+4];

  While Minimap.IsPlayerMoving(200) do
    Wait(75);

  if Upper then
  begin
    if Self.RSW.GetMyPos.DistanceTo(Self.LadderObj.WalkTile) > 10 then
      if (not Self.RSW.WalkBlind(Self.LadderObj.WalkTile, 10)) then
        Antiban.RandomRotate();

    While Minimap.HasFlag do
    begin
      LadRect := Self.RSW.GetTileMS(LadderTTile);
      LadRect := LadRect.Expand(4);
      if SRL.FindColors(TPA, Self.LadderObj.Color, LadRect.Bounds) then
      begin
        SortTPAFrom(TPA, Self.RSW.GetTileMS([LadderTTile.X,LadderTTile.Y-5]).Mean);

        for 1 to 4 do
        begin
          Mouse.Move(TPA[Random(0,Min(High(TPA),10))]);
          if MainScreen.IsUpText(Self.LadderObj.UpText) then
            Break;
        end;

        if MainScreen.IsUpText(Self.LadderObj.UpText) then
        begin
          Mouse.Click(MOUSE_LEFT);
          if (not MainScreen.DidRedClick) then
            Exit(False)
          else
            Clicked := True;
        end;

        if Clicked then Break;
      end;
    end;

    if (not Clicked) then
    begin
      if Self.RSW.GetMyPos.DistanceTo(Self.LadderObj.WalkTile) > 10 then
      begin
        Self.MineZoneBlock();
        Self.RSW.WalkBlind(Self.LadderObj.WalkTile);
        While Minimap.IsPlayerMoving(200) do
          Wait(75);
      end;

      LadRect := Self.RSW.GetTileMS(LadderTTile);
      LadRect := LadRect.Expand(4);
      if SRL.FindColors(TPA, Self.LadderObj.Color, LadRect.Bounds) then
      begin
        SortTPAFrom(TPA, Self.RSW.GetTileMS([LadderTTile.X,LadderTTile.Y-5]).Mean);

        for 1 to 4 do
        begin
          Mouse.HumanMove(TPA[Random(0,Min(High(TPA),10))]);
          if MainScreen.IsUpText(Self.LadderObj.UpText) then
            Break;
        end;

        if MainScreen.IsUpText(Self.LadderObj.UpText) then
        begin
          Mouse.Click(MOUSE_LEFT);
          if (not MainScreen.DidRedClick) then
            Exit(False)
          else
            Clicked := True;
        end else
        begin
          Self.WriteMsg('Failed to find the ladder [top]');
          Antiban.RandomRotate();
          Inc(Self.FailCount);
          Exit;
        end;
      end else
      begin
        Self.WriteMsg('Failed to find ladder colors [top]');
        Antiban.RandomRotate();
        Inc(Self.FailCount);
        Exit;
      end;
    end;
  end else
  begin
    if (not Self.LadderObj.Interact()) then
    begin
      LadRect := Self.RSW.GetTileMS(LadderBTile);
      LadRect := LadRect.Expand(4);
      if SRL.FindColors(TPA, Self.LadderObj.Color, LadRect.Bounds) then
      begin
        SortTPAFrom(TPA, Self.RSW.GetTileMS([LadderBTile.X,LadderBTile.Y+5]).Mean);

        for 1 to 4 do
        begin
          Mouse.HumanMove(TPA[Random(0,Min(High(TPA),10))]);
          if MainScreen.IsUpText(Self.LadderObj.UpText) then
            Break;
        end;

        if (not MainScreen.IsUpText(Self.LadderObj.UpText)) then
        begin
          Self.WriteMsg('Failed to find the ladder [bottom]');
          Antiban.RandomRotate();
          Inc(Self.FailCount);
          Exit;
        end;

        Mouse.Click(MOUSE_LEFT);
        if (not MainScreen.DidRedClick) then Exit(False);
      end else
      begin
        Self.WriteMsg('Failed to find the ladder [bottom]');
        Antiban.RandomRotate();
        Inc(Self.FailCount);
        Exit;
      end;
    end;
  end;

  Minimap.WaitFlag(5);

  if Upper then
    Result := WaitUntil((not Self.OnUpperLevel), 115, 7000)
  else
  begin
    Result := WaitUntil(Self.OnUpperLevel, 115, 7000);
    if Result then
      for 1 to 10 do // 2500ms timeout
        if (SRL.GetPixelShift(Mainscreen.Bounds(), 250) / Mainscreen.Bounds.Area() * 100) < 10 then // less than 10% of the screen changed in 250ms
          Break;

    if Result then
      if SAMEZONE then
        Self.NavigateToZone(Self.PrevZone)
      else
        Self.NavigateToZone(Self.GetRandomFreeZone());
  end;

  if (not Result) then
  begin
    Self.WriteMsg('Failed to climb the ladder [0]');
    Self.HopWorlds();
    Inc(Self.FailCount);
  end else
    Self.FailCount := 0;
end;

function TScript.SearchSack(): Boolean; forward;
function TScript.DepositOres(): Boolean; forward;
function TScript.DepostDirt(): Boolean;
begin
  if (not RSClient.IsLoggedIn) then Exit;
  if DEBUGMODE then
    Self.WriteMsg('Depositing pay-dirt');

  if (not Self.HopperObj.Interact()) then
  begin
    Inc(Self.FailCount);
    Antiban.RandomRotate();
    Exit(False);
  end;

  Minimap.WaitFlag(5);
  Result := WaitUntil((Inventory.Count() <= 10), 75, 4000);

  if (not Result) then
  begin
    if (('reach that' in Chat.GetMessage(7, [CHAT_COLOR_BLACK])) or Self.OnUpperLevel) then
    begin
      Self.HandleLadder();
      Inc(Self.FailCount);
      Exit;
    end;

    if (not Self.WaterIsFlowing()) then
    begin
      if (not Self.RepairStrut()) then
      begin
        Self.NavigateToPlace('North strut');
        for 1 to 2 do
          if Self.RepairStrut() then
            break;
      end;
    end else
    begin
      if DEBUGMODE then
        Self.WriteMsg('Dropping pay-dirt');

      Inventory.ShiftDrop(Self.GetPaydirtSlots);
      if Self.SearchSack then
      begin
        if (not Self.DepositOres) then
          if DEBUGMODE then
            Self.WriteMsg('Issue deposting ores');
      end;

      Self.NavigateToPlace('Hopper');
      Self.TakeGroundItems;
    end;
  end else
    Self.FailCount := 0;

  if DROPHAMMER then
    if SRL.Dice(75) then
      Inventory.ShiftDrop(['Hammer'], DROP_PATTERN_REGULAR)
    else
      Inventory.ClickItem('Hammer', 'Drop');
end;

function TScript.SearchSack(): Boolean;
var
  DBMSPt: TPoint;
  Clicked: Boolean;
begin
  if (not RSClient.IsLoggedIn) then Exit;
  if Inventory.IsFull() then Exit;

  if DEBUGMODE then
    Self.WriteMsg('Searching sack');

  if DepositBox.IsOpen() then
  begin
    DepositBox.Close();
    Exit;
  end;

  if (not Self.HasOres()) then
  begin
    for 1 to 3 do
    begin
      if (not RSClient.IsLoggedIn) then Exit;
      if Self.SackObj.Interact() then
      begin
        Clicked := True;
        break;
      end;

      Inc(Self.FailCount);
      if (not Mainscreen.DidYellowClick) then
        Antiban.RandomRotate;
    end;

    if (not Clicked) then Exit;
  end;

  if SRL.Dice(Random(60,85)) then
  begin
    Minimap.WaitFlag(Random(12,17));
    DBMSPt := Self.RSW.GetTileMSEx(Self.SackObj.WalkTile, Self.DBObj.WalkTile).Mean;
    if Mainscreen.Bounds.Contains(DBMSPt) then
      Mouse.Move(DBMSPt);
  end;

  Minimap.WaitFlag(5);
  Result := WaitUntil(Self.HasOres(), 75, 7000);

  if (not Result) then
  begin
    Inc(Self.FailCount);
    Self.HopWorlds();
  end else
    Self.FailCount := 0;
end;

function TScript.DepositOres(): Boolean;
var
  AllItems: TStringArray := ['Coal','Gold ore','Mithril ore','Adamantite ore','Runite ore',
                             'Golden nugget','Uncut sapphire','Uncut emerald','Uncut ruby',
                             'Uncut diamond'];

  First: Boolean := SRL.Dice(80);
  Clicked: Boolean;
  Item: TRSItem;
begin
  if (not RSClient.IsLoggedIn) then Exit;
  if (not Depositbox.IsOpen) then
    if (not Self.HasOres()) then Exit;

  if DEBUGMODE then
    Self.WriteMsg('Depositing ores');

  if (not DepositBox.IsOpen()) then
  begin
    for 1 to 3 do
    begin
      if (not DepositBox.IsOpen()) then
        if Self.DBObj.Interact() then
        begin
          Clicked := True;
          break;
        end;

      Inc(Self.FailCount);
      if (not Mainscreen.DidYellowClick) then
        Antiban.RandomRotate;
    end;

    if Clicked then
    begin
      Minimap.WaitFlag(5);
      if (not DepositBox.IsOpen(6500)) then
      begin
        if DEBUGMODE then
          Self.WriteMsg('Deposit box clicked but never opened');
        Self.HopWorlds();
        Exit;
      end;
    end else
    begin
      if DEBUGMODE then
        Self.WriteMsg('Failed to click the deposit box');
      Exit;
    end;
  end;

  Inc(Self.CoalC, DepositBox.CountItem('Coal'));
  Inc(Self.GoldC, DepositBox.CountItem('Gold ore'));
  Inc(Self.MithC, DepositBox.CountItem('Mithril ore'));
  Inc(Self.AddyC, DepositBox.CountItem('Adamantite ore'));
  Inc(Self.RuneC, DepositBox.CountItem('Runite ore'));
  Inc(Self.NugC,  Max(DepositBox.CountItemStack('Golden nugget'),0));

  if (Self.ToolSlot > -1) or (DepositBox.FindItem('Open gem bag')) then
  begin
    if Self.EmptyGemBag then
      if First then
        DepositBox.ClickItem('Open gem bag', 'Empty');
    if SRL.Dice(85) then
      AllItems.Reverse();
    for Item in AllItems do
    begin
      DepositBox.DepositItem([Item,-1], True);
      Wait(SRL.NormalRange(150,400));
    end;
    if Self.EmptyGemBag then
      if (not First) then
        DepositBox.ClickItem('Open gem bag', 'Empty');

    Self.EmptyGemBag := False;
  end else
    DepositBox.DepositAll();

  DepositBox.Close();
  Result := WaitUntil((Inventory.Count() <= 5), 75, 4000);
  if Result then Self.FailCount := 0;

  Self.Report();
end;

procedure TScript.MineVeins();
var
  i,XP,Ang,Ang2: Int32;
  Vein,MyPos: TPoint;
  MyZone: TZone;
  DoRotate: Boolean;
  T: TCountdown;
  NearVeins: TPointArray;
begin
  if (not RSClient.IsLoggedIn) then Exit;

  if Inventory.ContainsItem('Gem bag') then
    Inventory.ClickItem('Gem bag', 'Open');

  Self.EmptyGemBag := True;

  MyPos  := Self.RSW.GetMyPos;
  MyZone := Self.GetCurrentZone;
  Ang    := Self.GetZoneAngle(True, MyZone, MyPos);
  Ang2   := Self.GetZoneAngle(False, MyZone, MyPos);

  if (not InRange(Minimap.GetCompassAngle(True), Ang-15, Ang+15)) and
     (not InRange(Minimap.GetCompassAngle(True), Ang2-15, Ang2+15)) then
  begin
    Ang := Self.GetZoneAngle(True, MyZone, MyPos);
    if DEBUGMODE then
      Self.WriteMsg('Rotating to angle: '+ToStr(Ang));
    Minimap.SetCompassAngle(Ang);
  end;

  for i:=0 to 2 do
  begin
    MainScreen.SetHighestPitch;
    NearVeins := Self.GetVeinsInMyZone(MyZone);
    if NearVeins.Len > 0 then break;

    case i of
      0:
      begin
        if InRange(Minimap.GetCompassAngle(), Ang-15, Ang+15) then // Best angle
          Ang := Self.GetZoneAngle(False, MyZone, MyPos)
        else
          Ang := Self.GetZoneAngle(True, MyZone, MyPos);

        if DEBUGMODE then
          Self.WriteMsg('Rotating to angle: '+ToStr(Ang));

        Minimap.SetCompassAngle(Ang);
      end;
      1:
      begin
        if DEBUGMODE then
          Self.WriteMsg('No veins found nearby, switching spots in zone');

        Self.RelocateInZone();
        MyPos  := Self.RSW.GetMyPos;
        MyZone := Self.GetCurrentZone;
        Ang    := Self.GetZoneAngle(True, MyZone, MyPos);

        if (not InRange(Minimap.GetCompassAngle(), Ang-15, Ang+15)) then
        begin
          if DEBUGMODE then
            Self.WriteMsg('Rotating to angle: '+ToStr(Ang));

          Minimap.SetCompassAngle(Ang);
        end;
      end;
      2:
      begin
        if DEBUGMODE then
          Self.WriteMsg('No veins found nearby, switching zones');
        if LOWERLEVELONLY then
          TerminateScript('Couldnt find any spots in lower zone');
        Self.NavigateToZone(Self.GetRandomZone(True));
        Exit;
      end;
    end;
  end;

  Self.PrevZone := Self.GetCurrentZone();
  for Vein in NearVeins do
  begin
    Mouse.Move(Vein);
    if MainScreen.IsUpText(['Mine Vein', 'Mine'], 150) then
      break;
  end;

  if (not MainScreen.IsUpText(['Mine Vein', 'Mine'], 150)) then
  begin
    Antiban.RandomRotate();
    Exit;
  end;

  Mouse.Click(MOUSE_LEFT);

  if (not MainScreen.DidRedClick) then Exit;

  XP := XPBar.Read();

  Minimap.WaitFlag(2);

  T.Init(SRL.NormalRange(1200,1750));

  while (not T.IsFinished) do
  begin
    if (not RSClient.IsLoggedIn) then Exit;
    if Inventory.IsFull() then break;

    if HOPONCHAT then
      Self.CheckForChat();

    if Chat.ClickContinue(False) then
    begin
      T.Restart;
      continue;
    end;

    if XPBar.Read() > XP then
    begin
      XP := XPBar.Read();
      T.Restart();
      continue;
    end;

    if (SRL.PercentShift(MainScreen.GetPlayerBox(), 500) >= PERCSHIFT) then
    begin
      T.Restart();
      continue;
    end;

    if Self.DoAB() then
    begin
      T.Restart();
      continue;
    end;



    if 'reach that' in Chat.GetMessage(7, [CHAT_COLOR_BLACK]) then
    begin
      Self.MineZoneBlock(Self.GetCurrentZone(), True);
      Exit;
    end;

    Wait(250);
  end;
end;

procedure OnWalkEvent(Sender: PRSWalker; Position: TPoint; Destination: TPoint);
begin
  if DepositBox.IsOpen() then
    DepositBox.Close();
  if Bank.IsOpen() then
    Bank.Close();
  Sender^.Enabled := True;
  Position    := [];
  Destination := [];
end;
function TScript.GetState(): EState;
begin
  Result := MINING;
  if Self.HasOres() then
    Exit(DEPOSIT_ORES);

  if DepositBox.IsOpen() then DepositBox.Close();

  if Inventory.Count() >= 27 then
  begin
    if ((Self.GetSackCount() + Self.CountPayDirt) >= Self.PayDirtLimit) then
      Exit(DEPOSIT_ORES);

    if Self.CountPayDirt() > 0 then
      Exit(DEPOSIT_PAYDIRT)
  end;
end;

procedure TScript.Run();
var CurState: EState;
begin
  if (not RSClient.IsLoggedIn) then
    if Login.GetPlayer.Password <> '' then
      Login.LoginPlayer
    else
    begin
      Self.WriteMsg('No player credentials');
      Exit;
    end;

  while (GetTimeRunning() < Self.ShutdownTime) do
  begin
    if (not RSClient.IsLoggedIn) then
    begin
      if Login.GetPlayer.Password <> '' then
        Login.LoginPlayer
      else
      begin
        Logout.ClickLogout();
        TerminateScript('No player credentials');
      end;
    end;

   if Self.FindReachMsg() then
    begin
      Self.WriteMsg('Cannot reach an object, hopping worlds');
      Self.HopWorlds;
    end;

    if Self.FailCount > 4 then
    begin
      Logout.ClickLogout();
      TerminateScript('Script failure limit reached');
    end;

    if DepositBox.IsOpen() then DepositBox.Close;

    case Self.GetState() of
      MINING:
      begin
        if (Self.GetCurrentZone.Area = []) then
        begin
          if (not Self.MineZoneBlock(Self.Zones[3])) then
          begin
            Self.WriteMsg('Failed to mine zoneblock when mining');
            Continue;
          end;
          if SAMEZONE then
            Self.NavigateToZone(Self.Zones[3])
          else
            Self.NavigateToZone(Self.GetRandomFreeZone());
        end else
          Self.MineVeins();
      end;
      DEPOSIT_PAYDIRT:
      begin
      writeln('minzeonblockdepositpaydirt');
      if (distance(RSW.GetMyPos,Zones[3].Block) < 84) then
        Self.MineZoneBlock(Self.Zones[3]);
//      TerminateScript('deposit time');
        if (not Self.DepostDirt()) then
        begin
          Self.NavigateToPlace('Hopper');
          Continue;
        end;
      end;
      DEPOSIT_ORES:
      begin
        if not (Self.GetCurrentZone.Area = []) then
          for 1 to 3 do
            if (not Self.MineZoneBlock(Self.Zones[3])) then
            begin
              Self.WriteMsg('Failed to mine zoneblock in deposit_ores');
              Continue;
            end else
              break;

        if Self.CountPayDirt() > 0 then
          for 1 to 3 do
            if (not Self.DepostDirt()) then
              Self.NavigateToPlace('Hopper')
            else
              break;
        while Self.GetSackCount() > 0 do
        begin
          if Self.CountPayDirt() > 0 then
          begin
            Logout.ClickLogout();
            TerminateScript('Pay-dirt overload');
            Exit;
          end;

        if Self.HasOres() then
          Self.DepositOres();
      end;
    end;
  end;

  Logout.ClickLogout();
  TerminateScript('Time to shutdown');
end;

procedure TScript.Free();
begin
  RSClient.Image.Clear();
  FreeDTM(Self.DTM_PayDirt);
  Self.WriteMsg('Thanks for using Flight'#39's Motherlode-Miner!');
end;

procedure TScript.DebugMSPoly(MMTiles: TPointArray);
var
  MSPnt,Pnt: TPoint;
  TPA,MMPnts: TPointArray;
begin
  RSClient.Image.SetFontName('Bahnschrift');
  RSClient.Image.SetFontSize(13);
  RSClient.Image.SetFontAntialiasing(False);

  for Pnt in MMTiles do
    MMPnts += Self.RSW.WorldToMM(Pnt);

  for Pnt in MMPnts do
  begin
    MSPnt := Minimap.PointToMs(Pnt);
    if MainScreen.IsVisible(MSPnt) then
      TPA += MSPnt;
  end;

  RSClient.Image.Clear(Mainscreen.Bounds);
  RSClient.Image.DrawTPA(TPA.Connect(), clWhite);
end;

procedure TScript.Init();
begin
  Self.Version            := 'BETA Final';
  Mouse.Speed             := Random(21, 27);
  ASyncMouse.Speed        := Mouse.Speed+SRL.NormalRange(2,5);
  Mouse.CanIdle           := False;
  Mouse.MissChance        := 13;
  Mouse.Brake             := True;
  Mouse.Distribution      := MOUSE_DISTRIBUTION_GAUSS;

  Login.AddPlayer(PNAME, PPASS, '', []);
  RSClient.Image.Clear(Mainscreen.Bounds);

  MM2MS.ZoomLevel         := Options.GetZoomLevel();
  Antiban.OnStartBreak    := @PauseRunTime;
  Antiban.OnFinishBreak   := @ResumeRunTime;

  with Self do
  begin
    StartXP               := XPBar.Read();
    ToolSlot              := -1;
    if LARGESACK then
      PayDirtLimit        := 161
    else
      PayDirtLimit        := 80;

    DTM_PayDirt           := DTMFromString('mKgEAAHicpc3NCkBQEIbhOZ1sucizcwVW7CQ/G+6IiKQUG7kZr8wNYOr5msV8jS8imRVJVIRY9xQFapSo0NjnPsdsRDqMWNSBDSd2rJgwoEWP0Dm+mtcC0vvgbv+fCz5nFGI=');

    if RSW.FindMap('MotherlodeMine2') = '' then
      DownloadToFile('https://i.imgur.com/YrhVnMG.png', IncludePath+'\SRL-F\osr\walker\maps\MotherlodeMine2.png');

    RSW.Setup('MotherlodeMine2', True, 2);
    RSW.ScreenWalk        := SCREENWALK;
    RSW.EnableRunAtEnergy := 85;
    UpperLevelBounds      := [[276,133], [277,157], [287,160], [290,169], [295,173],
                              [302,178], [309,181], [314,188], [324,199], [336,199],
                              [351,164], [345,157], [343,138], [327,130], [292,130]];
    LowerLevelBounds      := [[135,222],[155,345],[177,222],[177,345]];

    SetLength(Zones, 4);
    with Zones[0] do
    begin
      Area      := [[310,174], [313,185], [320,188], [326,201], [334,202],
                    [333,180], [321,176]];
      Veins     := [[316,177], [321,180], [325,180], [328,180], [335,184],
                    [335,188], [335,191], [335,195]];
      WalkTiles := [[312,178], [319,184], [326,187], [327, 194]];
      Block     := [0,0];
    end;
    with Zones[1] do
    begin
      Area      := [[317,156], [316,170], [327,178], [339,179], [347,171],
                    [349,162], [343,156], [343,140], [334,139], [333,150]];
      Veins     := [[325,155], [328,155], [332,155], [345,169], [341,169],
                    [332,175], [328,175], [321,171], [338,152], [338,148],
                    [338,143]];
      WalkTiles := [[320,166], [329,169], [328,160], [341,160], [342,148]];
      Block     := [314,167];
    end;
    with Zones[2] do
    begin
      Area      := [[303,163], [314,168], [319,156], [333,153], [334,140],
                    [327,131], [315,131], [302,138], [303,149]];
      Veins     := [[308,163], [308,159], [305,152], [305,148], [305,144],
                    [310,139], [314,139], [317,156], [317,152], [321,147],
                    [329,150], [333,147], [333,143], [315,136]];
      WalkTiles := [[313,161], [312,153], [309,145], [324,140]];
      Block     := [314,167];
    end;
    with Zones[3] do
    begin
      Area      := [[152, 221], [160, 218], [168, 214], [173, 216], [174, 221], [175, 226], [177, 232], [177, 240], [178, 252], [179, 276], [178, 288], [178, 304], [180, 314], [178, 329], [176, 338], [172, 340], [164, 345], [156, 345], [149, 343], [140, 341], [136, 335], [135, 324], [134, 314], [137, 304], [140, 294], [138, 285], [138, 275], [141, 266], [138, 250], [138, 238], [146, 234], [153, 232]];
      Veins     := [[158, 227], [159, 231], [153, 241], [149, 241], [142, 247], [142, 252], [142, 256], [146, 262], [146, 266], [146, 271], [146, 286], [146, 291], [146, 295], [138, 315], [139, 320], [139, 325], [145, 338], [149, 338], [157, 341], [161, 342], [168, 337], [172, 337], [160, 320], [164, 320], [155, 311], [155, 316], [170, 315], [170, 311], [170, 305], [155, 271], [155, 267], [155, 262], [160, 257], [166, 257], [170, 263], [170, 268], [175, 239], [171, 226], [171, 222], [171, 218]];
      WalkTiles := [[163, 227], [169, 225], [168, 231], [163, 232], [163, 238], [169, 237], [168, 243], [161, 243], [155, 244], [150, 246], [147, 250], [157, 250], [163, 250], [168, 250], [171, 255], [174, 260], [175, 264], [175, 269], [171, 274], [163, 254], [156, 254], [150, 256], [150, 262], [151, 267], [150, 272], [150, 277], [152, 283], [157, 281], [164, 281], [170, 281], [170, 287], [164, 287], [156, 286], [151, 289], [157, 291], [167, 293], [174, 294], [176, 298], [178, 305], [177, 310], [178, 320], [174, 326], [169, 329], [161, 331], [154, 332], [148, 332], [145, 324], [154, 324], [161, 324], [142, 317], [151, 316], [146, 309], [151, 309], [148, 301], [153, 301], [150, 295], [157, 296], [164, 297]];
      Block     := [195,271];
    end;
    //while true do writeln distance(RSW.GetMyPos,Zones[3].Block);
    with LadderObj do
    begin
      Color    := CTS2(4544353, 10, 0.11, 0.12);
      UpText   := ['Climb'];
      Tiles    := [LadderTTile,LadderBTile];
      WalkTile := [LadderTTile.X,LadderTTile.Y-4];
      Expand   := 4;
    end;

    with HopperObj do
    begin
      Color    := CTS2(5662312, 17, 0.21, 0.49);
      UpText   := ['Deposit','Hopper'];
      Tiles    := [HopperTile];
      WalkTile := [HopperTile.X+4,HopperTile.Y];
      Expand   := 10;
    end;

    with SackObj do
    begin
      Color    := CTS2(4349035, 12, 0.07, 0.70);
      UpText   := ['Search','Sack'];
      Tiles    := [SackTile];
      WalkTile := [SackTile.X+8,SackTile.Y];
      Expand   := 10;
    end;

    with DBObj do
    begin
      Color    := CTS2(6847623, 8, 0.10, 0.49);
      UpText   := ['Deposit','Bank Deposit'];
      Tiles    := [DBTile];
      WalkTile := [DBTile.X-4,DBTile.Y];
      Expand   := 10;
    end;

    if (not HasTool()) then
    begin
      Logout.ClickLogout();
      TerminateScript('Pickaxe not found');
    end;

    SetupAntiban();
    BlockCoolDown.Start();
    TrueRunTime.Start();
    ShutdownTime := (MAXRUNTIME*60000)+Random(-(MAXRUNTIME*6000),(MAXRUNTIME*6000));
  end;

  AddOnTerminate(@Self.Free);
end;

begin
  //ClearDebug();
  Bot.Init();
  Bot.Run();
end.
